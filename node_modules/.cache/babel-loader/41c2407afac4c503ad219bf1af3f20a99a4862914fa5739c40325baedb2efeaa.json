{"ast":null,"code":"/**\n * @typedef {import('mdast').Delete} Delete\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n */\n\nimport { containerPhrasing } from 'mdast-util-to-markdown/lib/util/container-phrasing.js';\nimport { track } from 'mdast-util-to-markdown/lib/util/track.js';\n\n// To do: next major: expose functions.\n// To do: next major: use `state`, state utilities.\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain strikethrough.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>\n *\n * @type {Array<ConstructName>}\n */\nconst constructsWithoutStrikethrough = ['autolink', 'destinationLiteral', 'destinationRaw', 'reference', 'titleQuote', 'titleApostrophe'];\nhandleDelete.peek = peekDelete;\n\n/**\n * Extension for `mdast-util-from-markdown` to enable GFM strikethrough.\n *\n * @type {FromMarkdownExtension}\n */\nexport const gfmStrikethroughFromMarkdown = {\n  canContainEols: ['delete'],\n  enter: {\n    strikethrough: enterStrikethrough\n  },\n  exit: {\n    strikethrough: exitStrikethrough\n  }\n};\n\n/**\n * Extension for `mdast-util-to-markdown` to enable GFM strikethrough.\n *\n * @type {ToMarkdownExtension}\n */\nexport const gfmStrikethroughToMarkdown = {\n  unsafe: [{\n    character: '~',\n    inConstruct: 'phrasing',\n    notInConstruct: constructsWithoutStrikethrough\n  }],\n  handlers: {\n    delete: handleDelete\n  }\n};\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterStrikethrough(token) {\n  this.enter({\n    type: 'delete',\n    children: []\n  }, token);\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitStrikethrough(token) {\n  this.exit(token);\n}\n\n/**\n * @type {ToMarkdownHandle}\n * @param {Delete} node\n */\nfunction handleDelete(node, _, context, safeOptions) {\n  const tracker = track(safeOptions);\n  const exit = context.enter('strikethrough');\n  let value = tracker.move('~~');\n  value += containerPhrasing(node, context, {\n    ...tracker.current(),\n    before: value,\n    after: '~'\n  });\n  value += tracker.move('~~');\n  exit();\n  return value;\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDelete() {\n  return '~';\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}