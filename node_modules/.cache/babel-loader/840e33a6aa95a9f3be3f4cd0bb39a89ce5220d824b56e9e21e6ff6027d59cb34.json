{"ast":null,"code":"import { Matrix4, Box3 } from 'three';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/******************************************************/\n/* This file is generated from \"bvhcast.template.js\". */\n/******************************************************/\n\nconst tempMatrix = new Matrix4();\nconst aabb = /* @__PURE__ */new Box3();\nconst aabb2 = /* @__PURE__ */new Box3();\nfunction bvhcast(bvh, otherBvh, matrixToLocal, callbacks) {\n  // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n  // than an approach that walks down the tree (see bvhcast.js file for more info).\n\n  let {\n    intersectsRanges,\n    intersectsTriangles\n  } = callbacks;\n  const indexAttr = bvh.geometry.index;\n  const positionAttr = bvh.geometry.attributes.position;\n  const otherIndexAttr = otherBvh.geometry.index;\n  const otherPositionAttr = otherBvh.geometry.attributes.position;\n  tempMatrix.copy(matrixToLocal).invert();\n  const triangle = ExtendedTrianglePool.getPrimitive();\n  const triangle2 = ExtendedTrianglePool.getPrimitive();\n  if (intersectsTriangles) {\n    const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {\n      for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n        setTriangle(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);\n        triangle2.a.applyMatrix4(matrixToLocal);\n        triangle2.b.applyMatrix4(matrixToLocal);\n        triangle2.c.applyMatrix4(matrixToLocal);\n        triangle2.needsUpdate = true;\n        for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n          setTriangle(triangle, i1 * 3, indexAttr, positionAttr);\n          triangle.needsUpdate = true;\n          if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    if (intersectsRanges) {\n      const originalIntersectsRanges = intersectsRanges;\n      intersectsRanges = function (offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n        if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n          return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n        }\n        return true;\n      };\n    } else {\n      intersectsRanges = iterateOverDoubleTriangles;\n    }\n  }\n  otherBvh.getBoundingBox(aabb2);\n  aabb2.applyMatrix4(matrixToLocal);\n  const result = bvh.shapecast({\n    intersectsBounds: box => aabb2.intersectsBox(box),\n    intersectsRange: (offset1, count1, contained, depth1, nodeIndex1, box) => {\n      aabb.copy(box);\n      aabb.applyMatrix4(tempMatrix);\n      return otherBvh.shapecast({\n        intersectsBounds: box => aabb.intersectsBox(box),\n        intersectsRange: (offset2, count2, contained, depth2, nodeIndex2) => {\n          return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n        }\n      });\n    }\n  });\n  ExtendedTrianglePool.releasePrimitive(triangle);\n  ExtendedTrianglePool.releasePrimitive(triangle2);\n  return result;\n}\nexport { bvhcast };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}