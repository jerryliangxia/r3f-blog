{"ast":null,"code":"import $fnFM9$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport { forwardRef as $fnFM9$forwardRef, useState as $fnFM9$useState, createElement as $fnFM9$createElement, useRef as $fnFM9$useRef, Fragment as $fnFM9$Fragment, useEffect as $fnFM9$useEffect, useCallback as $fnFM9$useCallback, useReducer as $fnFM9$useReducer } from \"react\";\nimport { Primitive as $fnFM9$Primitive } from \"@radix-ui/react-primitive\";\nimport { Presence as $fnFM9$Presence } from \"@radix-ui/react-presence\";\nimport { createContextScope as $fnFM9$createContextScope } from \"@radix-ui/react-context\";\nimport { useComposedRefs as $fnFM9$useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { useCallbackRef as $fnFM9$useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useDirection as $fnFM9$useDirection } from \"@radix-ui/react-direction\";\nimport { useLayoutEffect as $fnFM9$useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { clamp as $fnFM9$clamp } from \"@radix-ui/number\";\nimport { composeEventHandlers as $fnFM9$composeEventHandlers } from \"@radix-ui/primitive\";\nfunction $6c2e24571c90391f$export$3e6543de14f8614f(initialState, machine) {\n  return $fnFM9$useReducer((state, event) => {\n    const nextState = machine[state][event];\n    return nextState !== null && nextState !== void 0 ? nextState : state;\n  }, initialState);\n}\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollArea\n * -----------------------------------------------------------------------------------------------*/\nconst $57acba87d6e25586$var$SCROLL_AREA_NAME = 'ScrollArea';\nconst [$57acba87d6e25586$var$createScrollAreaContext, $57acba87d6e25586$export$488468afe3a6f2b1] = $fnFM9$createContextScope($57acba87d6e25586$var$SCROLL_AREA_NAME);\nconst [$57acba87d6e25586$var$ScrollAreaProvider, $57acba87d6e25586$var$useScrollAreaContext] = $57acba87d6e25586$var$createScrollAreaContext($57acba87d6e25586$var$SCROLL_AREA_NAME);\nconst $57acba87d6e25586$export$ccf8d8d7bbf3c2cc = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    __scopeScrollArea: __scopeScrollArea,\n    type = 'hover',\n    dir: dir,\n    scrollHideDelay = 600,\n    ...scrollAreaProps\n  } = props;\n  const [scrollArea, setScrollArea] = $fnFM9$useState(null);\n  const [viewport, setViewport] = $fnFM9$useState(null);\n  const [content, setContent] = $fnFM9$useState(null);\n  const [scrollbarX, setScrollbarX] = $fnFM9$useState(null);\n  const [scrollbarY, setScrollbarY] = $fnFM9$useState(null);\n  const [cornerWidth, setCornerWidth] = $fnFM9$useState(0);\n  const [cornerHeight, setCornerHeight] = $fnFM9$useState(0);\n  const [scrollbarXEnabled, setScrollbarXEnabled] = $fnFM9$useState(false);\n  const [scrollbarYEnabled, setScrollbarYEnabled] = $fnFM9$useState(false);\n  const composedRefs = $fnFM9$useComposedRefs(forwardedRef, node => setScrollArea(node));\n  const direction = $fnFM9$useDirection(dir);\n  return /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaProvider, {\n    scope: __scopeScrollArea,\n    type: type,\n    dir: direction,\n    scrollHideDelay: scrollHideDelay,\n    scrollArea: scrollArea,\n    viewport: viewport,\n    onViewportChange: setViewport,\n    content: content,\n    onContentChange: setContent,\n    scrollbarX: scrollbarX,\n    onScrollbarXChange: setScrollbarX,\n    scrollbarXEnabled: scrollbarXEnabled,\n    onScrollbarXEnabledChange: setScrollbarXEnabled,\n    scrollbarY: scrollbarY,\n    onScrollbarYChange: setScrollbarY,\n    scrollbarYEnabled: scrollbarYEnabled,\n    onScrollbarYEnabledChange: setScrollbarYEnabled,\n    onCornerWidthChange: setCornerWidth,\n    onCornerHeightChange: setCornerHeight\n  }, /*#__PURE__*/$fnFM9$createElement($fnFM9$Primitive.div, $fnFM9$babelruntimehelpersesmextends({\n    dir: direction\n  }, scrollAreaProps, {\n    ref: composedRefs,\n    style: {\n      position: 'relative',\n      // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n      ['--radix-scroll-area-corner-width']: cornerWidth + 'px',\n      ['--radix-scroll-area-corner-height']: cornerHeight + 'px',\n      ...props.style\n    }\n  })));\n});\n/*#__PURE__*/\nObject.assign($57acba87d6e25586$export$ccf8d8d7bbf3c2cc, {\n  displayName: $57acba87d6e25586$var$SCROLL_AREA_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaViewport\n * -----------------------------------------------------------------------------------------------*/\nconst $57acba87d6e25586$var$VIEWPORT_NAME = 'ScrollAreaViewport';\nconst $57acba87d6e25586$export$a21cbf9f11fca853 = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    __scopeScrollArea: __scopeScrollArea,\n    children: children,\n    ...viewportProps\n  } = props;\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$VIEWPORT_NAME, __scopeScrollArea);\n  const ref = $fnFM9$useRef(null);\n  const composedRefs = $fnFM9$useComposedRefs(forwardedRef, ref, context.onViewportChange);\n  return /*#__PURE__*/$fnFM9$createElement($fnFM9$Fragment, null, /*#__PURE__*/$fnFM9$createElement(\"style\", {\n    dangerouslySetInnerHTML: {\n      __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`\n    }\n  }), /*#__PURE__*/$fnFM9$createElement($fnFM9$Primitive.div, $fnFM9$babelruntimehelpersesmextends({\n    \"data-radix-scroll-area-viewport\": \"\"\n  }, viewportProps, {\n    ref: composedRefs,\n    style: {\n      /**\n      * We don't support `visible` because the intention is to have at least one scrollbar\n      * if this component is used and `visible` will behave like `auto` in that case\n      * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description\n      *\n      * We don't handle `auto` because the intention is for the native implementation\n      * to be hidden if using this component. We just want to ensure the node is scrollable\n      * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n      * the browser from having to work out whether to render native scrollbars or not,\n      * we tell it to with the intention of hiding them in CSS.\n      */\n      overflowX: context.scrollbarXEnabled ? 'scroll' : 'hidden',\n      overflowY: context.scrollbarYEnabled ? 'scroll' : 'hidden',\n      ...props.style\n    }\n  }), /*#__PURE__*/$fnFM9$createElement(\"div\", {\n    ref: context.onContentChange,\n    style: {\n      minWidth: '100%',\n      display: 'table'\n    }\n  }, children)));\n});\n/*#__PURE__*/\nObject.assign($57acba87d6e25586$export$a21cbf9f11fca853, {\n  displayName: $57acba87d6e25586$var$VIEWPORT_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaScrollbar\n * -----------------------------------------------------------------------------------------------*/\nconst $57acba87d6e25586$var$SCROLLBAR_NAME = 'ScrollAreaScrollbar';\nconst $57acba87d6e25586$export$2fabd85d0eba3c57 = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    forceMount: forceMount,\n    ...scrollbarProps\n  } = props;\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);\n  const {\n    onScrollbarXEnabledChange: onScrollbarXEnabledChange,\n    onScrollbarYEnabledChange: onScrollbarYEnabledChange\n  } = context;\n  const isHorizontal = props.orientation === 'horizontal';\n  $fnFM9$useEffect(() => {\n    isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);\n    return () => {\n      isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);\n    };\n  }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);\n  return context.type === 'hover' ? /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarHover, $fnFM9$babelruntimehelpersesmextends({}, scrollbarProps, {\n    ref: forwardedRef,\n    forceMount: forceMount\n  })) : context.type === 'scroll' ? /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarScroll, $fnFM9$babelruntimehelpersesmextends({}, scrollbarProps, {\n    ref: forwardedRef,\n    forceMount: forceMount\n  })) : context.type === 'auto' ? /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarAuto, $fnFM9$babelruntimehelpersesmextends({}, scrollbarProps, {\n    ref: forwardedRef,\n    forceMount: forceMount\n  })) : context.type === 'always' ? /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarVisible, $fnFM9$babelruntimehelpersesmextends({}, scrollbarProps, {\n    ref: forwardedRef\n  })) : null;\n});\n/*#__PURE__*/\nObject.assign($57acba87d6e25586$export$2fabd85d0eba3c57, {\n  displayName: $57acba87d6e25586$var$SCROLLBAR_NAME\n});\n/* -----------------------------------------------------------------------------------------------*/\nconst $57acba87d6e25586$var$ScrollAreaScrollbarHover = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    forceMount: forceMount,\n    ...scrollbarProps\n  } = props;\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [visible, setVisible] = $fnFM9$useState(false);\n  $fnFM9$useEffect(() => {\n    const scrollArea = context.scrollArea;\n    let hideTimer = 0;\n    if (scrollArea) {\n      const handlePointerEnter = () => {\n        window.clearTimeout(hideTimer);\n        setVisible(true);\n      };\n      const handlePointerLeave = () => {\n        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);\n      };\n      scrollArea.addEventListener('pointerenter', handlePointerEnter);\n      scrollArea.addEventListener('pointerleave', handlePointerLeave);\n      return () => {\n        window.clearTimeout(hideTimer);\n        scrollArea.removeEventListener('pointerenter', handlePointerEnter);\n        scrollArea.removeEventListener('pointerleave', handlePointerLeave);\n      };\n    }\n  }, [context.scrollArea, context.scrollHideDelay]);\n  return /*#__PURE__*/$fnFM9$createElement($fnFM9$Presence, {\n    present: forceMount || visible\n  }, /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarAuto, $fnFM9$babelruntimehelpersesmextends({\n    \"data-state\": visible ? 'visible' : 'hidden'\n  }, scrollbarProps, {\n    ref: forwardedRef\n  })));\n});\nconst $57acba87d6e25586$var$ScrollAreaScrollbarScroll = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    forceMount: forceMount,\n    ...scrollbarProps\n  } = props;\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);\n  const isHorizontal = props.orientation === 'horizontal';\n  const debounceScrollEnd = $57acba87d6e25586$var$useDebounceCallback(() => send('SCROLL_END'), 100);\n  const [state, send] = $6c2e24571c90391f$export$3e6543de14f8614f('hidden', {\n    hidden: {\n      SCROLL: 'scrolling'\n    },\n    scrolling: {\n      SCROLL_END: 'idle',\n      POINTER_ENTER: 'interacting'\n    },\n    interacting: {\n      SCROLL: 'interacting',\n      POINTER_LEAVE: 'idle'\n    },\n    idle: {\n      HIDE: 'hidden',\n      SCROLL: 'scrolling',\n      POINTER_ENTER: 'interacting'\n    }\n  });\n  $fnFM9$useEffect(() => {\n    if (state === 'idle') {\n      const hideTimer = window.setTimeout(() => send('HIDE'), context.scrollHideDelay);\n      return () => window.clearTimeout(hideTimer);\n    }\n  }, [state, context.scrollHideDelay, send]);\n  $fnFM9$useEffect(() => {\n    const viewport = context.viewport;\n    const scrollDirection = isHorizontal ? 'scrollLeft' : 'scrollTop';\n    if (viewport) {\n      let prevScrollPos = viewport[scrollDirection];\n      const handleScroll = () => {\n        const scrollPos = viewport[scrollDirection];\n        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n        if (hasScrollInDirectionChanged) {\n          send('SCROLL');\n          debounceScrollEnd();\n        }\n        prevScrollPos = scrollPos;\n      };\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);\n  return /*#__PURE__*/$fnFM9$createElement($fnFM9$Presence, {\n    present: forceMount || state !== 'hidden'\n  }, /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarVisible, $fnFM9$babelruntimehelpersesmextends({\n    \"data-state\": state === 'hidden' ? 'hidden' : 'visible'\n  }, scrollbarProps, {\n    ref: forwardedRef,\n    onPointerEnter: $fnFM9$composeEventHandlers(props.onPointerEnter, () => send('POINTER_ENTER')),\n    onPointerLeave: $fnFM9$composeEventHandlers(props.onPointerLeave, () => send('POINTER_LEAVE'))\n  })));\n});\nconst $57acba87d6e25586$var$ScrollAreaScrollbarAuto = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);\n  const {\n    forceMount: forceMount,\n    ...scrollbarProps\n  } = props;\n  const [visible, setVisible] = $fnFM9$useState(false);\n  const isHorizontal = props.orientation === 'horizontal';\n  const handleResize = $57acba87d6e25586$var$useDebounceCallback(() => {\n    if (context.viewport) {\n      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;\n      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;\n      setVisible(isHorizontal ? isOverflowX : isOverflowY);\n    }\n  }, 10);\n  $57acba87d6e25586$var$useResizeObserver(context.viewport, handleResize);\n  $57acba87d6e25586$var$useResizeObserver(context.content, handleResize);\n  return /*#__PURE__*/$fnFM9$createElement($fnFM9$Presence, {\n    present: forceMount || visible\n  }, /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarVisible, $fnFM9$babelruntimehelpersesmextends({\n    \"data-state\": visible ? 'visible' : 'hidden'\n  }, scrollbarProps, {\n    ref: forwardedRef\n  })));\n});\n/* -----------------------------------------------------------------------------------------------*/\nconst $57acba87d6e25586$var$ScrollAreaScrollbarVisible = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    orientation = 'vertical',\n    ...scrollbarProps\n  } = props;\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);\n  const thumbRef = $fnFM9$useRef(null);\n  const pointerOffsetRef = $fnFM9$useRef(0);\n  const [sizes, setSizes] = $fnFM9$useState({\n    content: 0,\n    viewport: 0,\n    scrollbar: {\n      size: 0,\n      paddingStart: 0,\n      paddingEnd: 0\n    }\n  });\n  const thumbRatio = $57acba87d6e25586$var$getThumbRatio(sizes.viewport, sizes.content);\n  const commonProps = {\n    ...scrollbarProps,\n    sizes: sizes,\n    onSizesChange: setSizes,\n    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),\n    onThumbChange: thumb => thumbRef.current = thumb,\n    onThumbPointerUp: () => pointerOffsetRef.current = 0,\n    onThumbPointerDown: pointerPos => pointerOffsetRef.current = pointerPos\n  };\n  function getScrollPosition(pointerPos, dir) {\n    return $57acba87d6e25586$var$getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);\n  }\n  if (orientation === 'horizontal') return /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarX, $fnFM9$babelruntimehelpersesmextends({}, commonProps, {\n    ref: forwardedRef,\n    onThumbPositionChange: () => {\n      if (context.viewport && thumbRef.current) {\n        const scrollPos = context.viewport.scrollLeft;\n        const offset = $57acba87d6e25586$var$getThumbOffsetFromScroll(scrollPos, sizes, context.dir);\n        thumbRef.current.style.transform = `translate3d(${offset}px, 0, 0)`;\n      }\n    },\n    onWheelScroll: scrollPos => {\n      if (context.viewport) context.viewport.scrollLeft = scrollPos;\n    },\n    onDragScroll: pointerPos => {\n      if (context.viewport) context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);\n    }\n  }));\n  if (orientation === 'vertical') return /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarY, $fnFM9$babelruntimehelpersesmextends({}, commonProps, {\n    ref: forwardedRef,\n    onThumbPositionChange: () => {\n      if (context.viewport && thumbRef.current) {\n        const scrollPos = context.viewport.scrollTop;\n        const offset = $57acba87d6e25586$var$getThumbOffsetFromScroll(scrollPos, sizes);\n        thumbRef.current.style.transform = `translate3d(0, ${offset}px, 0)`;\n      }\n    },\n    onWheelScroll: scrollPos => {\n      if (context.viewport) context.viewport.scrollTop = scrollPos;\n    },\n    onDragScroll: pointerPos => {\n      if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);\n    }\n  }));\n  return null;\n});\n/* -----------------------------------------------------------------------------------------------*/\nconst $57acba87d6e25586$var$ScrollAreaScrollbarX = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    sizes: sizes,\n    onSizesChange: onSizesChange,\n    ...scrollbarProps\n  } = props;\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [computedStyle, setComputedStyle] = $fnFM9$useState();\n  const ref = $fnFM9$useRef(null);\n  const composeRefs = $fnFM9$useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);\n  $fnFM9$useEffect(() => {\n    if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n  }, [ref]);\n  return /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarImpl, $fnFM9$babelruntimehelpersesmextends({\n    \"data-orientation\": \"horizontal\"\n  }, scrollbarProps, {\n    ref: composeRefs,\n    sizes: sizes,\n    style: {\n      bottom: 0,\n      left: context.dir === 'rtl' ? 'var(--radix-scroll-area-corner-width)' : 0,\n      right: context.dir === 'ltr' ? 'var(--radix-scroll-area-corner-width)' : 0,\n      ['--radix-scroll-area-thumb-width']: $57acba87d6e25586$var$getThumbSize(sizes) + 'px',\n      ...props.style\n    },\n    onThumbPointerDown: pointerPos => props.onThumbPointerDown(pointerPos.x),\n    onDragScroll: pointerPos => props.onDragScroll(pointerPos.x),\n    onWheelScroll: (event, maxScrollPos) => {\n      if (context.viewport) {\n        const scrollPos = context.viewport.scrollLeft + event.deltaX;\n        props.onWheelScroll(scrollPos); // prevent window scroll when wheeling on scrollbar\n        if ($57acba87d6e25586$var$isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) event.preventDefault();\n      }\n    },\n    onResize: () => {\n      if (ref.current && context.viewport && computedStyle) onSizesChange({\n        content: context.viewport.scrollWidth,\n        viewport: context.viewport.offsetWidth,\n        scrollbar: {\n          size: ref.current.clientWidth,\n          paddingStart: $57acba87d6e25586$var$toInt(computedStyle.paddingLeft),\n          paddingEnd: $57acba87d6e25586$var$toInt(computedStyle.paddingRight)\n        }\n      });\n    }\n  }));\n});\nconst $57acba87d6e25586$var$ScrollAreaScrollbarY = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    sizes: sizes,\n    onSizesChange: onSizesChange,\n    ...scrollbarProps\n  } = props;\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [computedStyle, setComputedStyle] = $fnFM9$useState();\n  const ref = $fnFM9$useRef(null);\n  const composeRefs = $fnFM9$useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);\n  $fnFM9$useEffect(() => {\n    if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n  }, [ref]);\n  return /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaScrollbarImpl, $fnFM9$babelruntimehelpersesmextends({\n    \"data-orientation\": \"vertical\"\n  }, scrollbarProps, {\n    ref: composeRefs,\n    sizes: sizes,\n    style: {\n      top: 0,\n      right: context.dir === 'ltr' ? 0 : undefined,\n      left: context.dir === 'rtl' ? 0 : undefined,\n      bottom: 'var(--radix-scroll-area-corner-height)',\n      ['--radix-scroll-area-thumb-height']: $57acba87d6e25586$var$getThumbSize(sizes) + 'px',\n      ...props.style\n    },\n    onThumbPointerDown: pointerPos => props.onThumbPointerDown(pointerPos.y),\n    onDragScroll: pointerPos => props.onDragScroll(pointerPos.y),\n    onWheelScroll: (event, maxScrollPos) => {\n      if (context.viewport) {\n        const scrollPos = context.viewport.scrollTop + event.deltaY;\n        props.onWheelScroll(scrollPos); // prevent window scroll when wheeling on scrollbar\n        if ($57acba87d6e25586$var$isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) event.preventDefault();\n      }\n    },\n    onResize: () => {\n      if (ref.current && context.viewport && computedStyle) onSizesChange({\n        content: context.viewport.scrollHeight,\n        viewport: context.viewport.offsetHeight,\n        scrollbar: {\n          size: ref.current.clientHeight,\n          paddingStart: $57acba87d6e25586$var$toInt(computedStyle.paddingTop),\n          paddingEnd: $57acba87d6e25586$var$toInt(computedStyle.paddingBottom)\n        }\n      });\n    }\n  }));\n});\n/* -----------------------------------------------------------------------------------------------*/\nconst [$57acba87d6e25586$var$ScrollbarProvider, $57acba87d6e25586$var$useScrollbarContext] = $57acba87d6e25586$var$createScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME);\nconst $57acba87d6e25586$var$ScrollAreaScrollbarImpl = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    __scopeScrollArea: __scopeScrollArea,\n    sizes: sizes,\n    hasThumb: hasThumb,\n    onThumbChange: onThumbChange,\n    onThumbPointerUp: onThumbPointerUp,\n    onThumbPointerDown: onThumbPointerDown,\n    onThumbPositionChange: onThumbPositionChange,\n    onDragScroll: onDragScroll,\n    onWheelScroll: onWheelScroll,\n    onResize: onResize,\n    ...scrollbarProps\n  } = props;\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, __scopeScrollArea);\n  const [scrollbar, setScrollbar] = $fnFM9$useState(null);\n  const composeRefs = $fnFM9$useComposedRefs(forwardedRef, node => setScrollbar(node));\n  const rectRef = $fnFM9$useRef(null);\n  const prevWebkitUserSelectRef = $fnFM9$useRef('');\n  const viewport = context.viewport;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const handleWheelScroll = $fnFM9$useCallbackRef(onWheelScroll);\n  const handleThumbPositionChange = $fnFM9$useCallbackRef(onThumbPositionChange);\n  const handleResize = $57acba87d6e25586$var$useDebounceCallback(onResize, 10);\n  function handleDragScroll(event) {\n    if (rectRef.current) {\n      const x = event.clientX - rectRef.current.left;\n      const y = event.clientY - rectRef.current.top;\n      onDragScroll({\n        x: x,\n        y: y\n      });\n    }\n  }\n  /**\n  * We bind wheel event imperatively so we can switch off passive\n  * mode for document wheel event to allow it to be prevented\n  */\n  $fnFM9$useEffect(() => {\n    const handleWheel = event => {\n      const element = event.target;\n      const isScrollbarWheel = scrollbar === null || scrollbar === void 0 ? void 0 : scrollbar.contains(element);\n      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);\n    };\n    document.addEventListener('wheel', handleWheel, {\n      passive: false\n    });\n    return () => document.removeEventListener('wheel', handleWheel, {\n      passive: false\n    });\n  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);\n  /**\n  * Update thumb position on sizes change\n  */\n  $fnFM9$useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);\n  $57acba87d6e25586$var$useResizeObserver(scrollbar, handleResize);\n  $57acba87d6e25586$var$useResizeObserver(context.content, handleResize);\n  return /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollbarProvider, {\n    scope: __scopeScrollArea,\n    scrollbar: scrollbar,\n    hasThumb: hasThumb,\n    onThumbChange: $fnFM9$useCallbackRef(onThumbChange),\n    onThumbPointerUp: $fnFM9$useCallbackRef(onThumbPointerUp),\n    onThumbPositionChange: handleThumbPositionChange,\n    onThumbPointerDown: $fnFM9$useCallbackRef(onThumbPointerDown)\n  }, /*#__PURE__*/$fnFM9$createElement($fnFM9$Primitive.div, $fnFM9$babelruntimehelpersesmextends({}, scrollbarProps, {\n    ref: composeRefs,\n    style: {\n      position: 'absolute',\n      ...scrollbarProps.style\n    },\n    onPointerDown: $fnFM9$composeEventHandlers(props.onPointerDown, event => {\n      const mainPointer = 0;\n      if (event.button === mainPointer) {\n        const element = event.target;\n        element.setPointerCapture(event.pointerId);\n        rectRef.current = scrollbar.getBoundingClientRect(); // pointer capture doesn't prevent text selection in Safari\n        // so we remove text selection manually when scrolling\n        prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;\n        document.body.style.webkitUserSelect = 'none';\n        handleDragScroll(event);\n      }\n    }),\n    onPointerMove: $fnFM9$composeEventHandlers(props.onPointerMove, handleDragScroll),\n    onPointerUp: $fnFM9$composeEventHandlers(props.onPointerUp, event => {\n      const element = event.target;\n      if (element.hasPointerCapture(event.pointerId)) element.releasePointerCapture(event.pointerId);\n      document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;\n      rectRef.current = null;\n    })\n  })));\n});\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaThumb\n * -----------------------------------------------------------------------------------------------*/\nconst $57acba87d6e25586$var$THUMB_NAME = 'ScrollAreaThumb';\nconst $57acba87d6e25586$export$9fba1154677d7cd2 = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    forceMount: forceMount,\n    ...thumbProps\n  } = props;\n  const scrollbarContext = $57acba87d6e25586$var$useScrollbarContext($57acba87d6e25586$var$THUMB_NAME, props.__scopeScrollArea);\n  return /*#__PURE__*/$fnFM9$createElement($fnFM9$Presence, {\n    present: forceMount || scrollbarContext.hasThumb\n  }, /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaThumbImpl, $fnFM9$babelruntimehelpersesmextends({\n    ref: forwardedRef\n  }, thumbProps)));\n});\nconst $57acba87d6e25586$var$ScrollAreaThumbImpl = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    __scopeScrollArea: __scopeScrollArea,\n    style: style,\n    ...thumbProps\n  } = props;\n  const scrollAreaContext = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$THUMB_NAME, __scopeScrollArea);\n  const scrollbarContext = $57acba87d6e25586$var$useScrollbarContext($57acba87d6e25586$var$THUMB_NAME, __scopeScrollArea);\n  const {\n    onThumbPositionChange: onThumbPositionChange\n  } = scrollbarContext;\n  const composedRef = $fnFM9$useComposedRefs(forwardedRef, node => scrollbarContext.onThumbChange(node));\n  const removeUnlinkedScrollListenerRef = $fnFM9$useRef();\n  const debounceScrollEnd = $57acba87d6e25586$var$useDebounceCallback(() => {\n    if (removeUnlinkedScrollListenerRef.current) {\n      removeUnlinkedScrollListenerRef.current();\n      removeUnlinkedScrollListenerRef.current = undefined;\n    }\n  }, 100);\n  $fnFM9$useEffect(() => {\n    const viewport = scrollAreaContext.viewport;\n    if (viewport) {\n      /**\n      * We only bind to native scroll event so we know when scroll starts and ends.\n      * When scroll starts we start a requestAnimationFrame loop that checks for\n      * changes to scroll position. That rAF loop triggers our thumb position change\n      * when relevant to avoid scroll-linked effects. We cancel the loop when scroll ends.\n      * https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Scroll-linked_effects\n      */\n      const handleScroll = () => {\n        debounceScrollEnd();\n        if (!removeUnlinkedScrollListenerRef.current) {\n          const listener = $57acba87d6e25586$var$addUnlinkedScrollListener(viewport, onThumbPositionChange);\n          removeUnlinkedScrollListenerRef.current = listener;\n          onThumbPositionChange();\n        }\n      };\n      onThumbPositionChange();\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);\n  return /*#__PURE__*/$fnFM9$createElement($fnFM9$Primitive.div, $fnFM9$babelruntimehelpersesmextends({\n    \"data-state\": scrollbarContext.hasThumb ? 'visible' : 'hidden'\n  }, thumbProps, {\n    ref: composedRef,\n    style: {\n      width: 'var(--radix-scroll-area-thumb-width)',\n      height: 'var(--radix-scroll-area-thumb-height)',\n      ...style\n    },\n    onPointerDownCapture: $fnFM9$composeEventHandlers(props.onPointerDownCapture, event => {\n      const thumb = event.target;\n      const thumbRect = thumb.getBoundingClientRect();\n      const x = event.clientX - thumbRect.left;\n      const y = event.clientY - thumbRect.top;\n      scrollbarContext.onThumbPointerDown({\n        x: x,\n        y: y\n      });\n    }),\n    onPointerUp: $fnFM9$composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)\n  }));\n});\n/*#__PURE__*/\nObject.assign($57acba87d6e25586$export$9fba1154677d7cd2, {\n  displayName: $57acba87d6e25586$var$THUMB_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaCorner\n * -----------------------------------------------------------------------------------------------*/\nconst $57acba87d6e25586$var$CORNER_NAME = 'ScrollAreaCorner';\nconst $57acba87d6e25586$export$56969d565df7cc4b = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$CORNER_NAME, props.__scopeScrollArea);\n  const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);\n  const hasCorner = context.type !== 'scroll' && hasBothScrollbarsVisible;\n  return hasCorner ? /*#__PURE__*/$fnFM9$createElement($57acba87d6e25586$var$ScrollAreaCornerImpl, $fnFM9$babelruntimehelpersesmextends({}, props, {\n    ref: forwardedRef\n  })) : null;\n});\n/*#__PURE__*/\nObject.assign($57acba87d6e25586$export$56969d565df7cc4b, {\n  displayName: $57acba87d6e25586$var$CORNER_NAME\n});\n/* -----------------------------------------------------------------------------------------------*/\nconst $57acba87d6e25586$var$ScrollAreaCornerImpl = /*#__PURE__*/$fnFM9$forwardRef((props, forwardedRef) => {\n  const {\n    __scopeScrollArea: __scopeScrollArea,\n    ...cornerProps\n  } = props;\n  const context = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$CORNER_NAME, __scopeScrollArea);\n  const [width1, setWidth] = $fnFM9$useState(0);\n  const [height1, setHeight] = $fnFM9$useState(0);\n  const hasSize = Boolean(width1 && height1);\n  $57acba87d6e25586$var$useResizeObserver(context.scrollbarX, () => {\n    var _context$scrollbarX;\n    const height = ((_context$scrollbarX = context.scrollbarX) === null || _context$scrollbarX === void 0 ? void 0 : _context$scrollbarX.offsetHeight) || 0;\n    context.onCornerHeightChange(height);\n    setHeight(height);\n  });\n  $57acba87d6e25586$var$useResizeObserver(context.scrollbarY, () => {\n    var _context$scrollbarY;\n    const width = ((_context$scrollbarY = context.scrollbarY) === null || _context$scrollbarY === void 0 ? void 0 : _context$scrollbarY.offsetWidth) || 0;\n    context.onCornerWidthChange(width);\n    setWidth(width);\n  });\n  return hasSize ? /*#__PURE__*/$fnFM9$createElement($fnFM9$Primitive.div, $fnFM9$babelruntimehelpersesmextends({}, cornerProps, {\n    ref: forwardedRef,\n    style: {\n      width: width1,\n      height: height1,\n      position: 'absolute',\n      right: context.dir === 'ltr' ? 0 : undefined,\n      left: context.dir === 'rtl' ? 0 : undefined,\n      bottom: 0,\n      ...props.style\n    }\n  })) : null;\n});\n/* -----------------------------------------------------------------------------------------------*/\nfunction $57acba87d6e25586$var$toInt(value) {\n  return value ? parseInt(value, 10) : 0;\n}\nfunction $57acba87d6e25586$var$getThumbRatio(viewportSize, contentSize) {\n  const ratio = viewportSize / contentSize;\n  return isNaN(ratio) ? 0 : ratio;\n}\nfunction $57acba87d6e25586$var$getThumbSize(sizes) {\n  const ratio = $57acba87d6e25586$var$getThumbRatio(sizes.viewport, sizes.content);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio; // minimum of 18 matches macOS minimum\n  return Math.max(thumbSize, 18);\n}\nfunction $57acba87d6e25586$var$getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = 'ltr') {\n  const thumbSizePx = $57acba87d6e25586$var$getThumbSize(sizes);\n  const thumbCenter = thumbSizePx / 2;\n  const offset = pointerOffset || thumbCenter;\n  const thumbOffsetFromEnd = thumbSizePx - offset;\n  const minPointerPos = sizes.scrollbar.paddingStart + offset;\n  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const scrollRange = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const interpolate = $57acba87d6e25586$var$linearScale([minPointerPos, maxPointerPos], scrollRange);\n  return interpolate(pointerPos);\n}\nfunction $57acba87d6e25586$var$getThumbOffsetFromScroll(scrollPos, sizes, dir = 'ltr') {\n  const thumbSizePx = $57acba87d6e25586$var$getThumbSize(sizes);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const scrollbar = sizes.scrollbar.size - scrollbarPadding;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const maxThumbPos = scrollbar - thumbSizePx;\n  const scrollClampRange = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const scrollWithoutMomentum = $fnFM9$clamp(scrollPos, scrollClampRange);\n  const interpolate = $57acba87d6e25586$var$linearScale([0, maxScrollPos], [0, maxThumbPos]);\n  return interpolate(scrollWithoutMomentum);\n} // https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction $57acba87d6e25586$var$linearScale(input, output) {\n  return value => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\nfunction $57acba87d6e25586$var$isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {\n  return scrollPos > 0 && scrollPos < maxScrollPos;\n} // Custom scroll handler to avoid scroll-linked effects\n// https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Scroll-linked_effects\nconst $57acba87d6e25586$var$addUnlinkedScrollListener = (node, handler = () => {}) => {\n  let prevPosition = {\n    left: node.scrollLeft,\n    top: node.scrollTop\n  };\n  let rAF = 0;\n  (function loop() {\n    const position = {\n      left: node.scrollLeft,\n      top: node.scrollTop\n    };\n    const isHorizontalScroll = prevPosition.left !== position.left;\n    const isVerticalScroll = prevPosition.top !== position.top;\n    if (isHorizontalScroll || isVerticalScroll) handler();\n    prevPosition = position;\n    rAF = window.requestAnimationFrame(loop);\n  })();\n  return () => window.cancelAnimationFrame(rAF);\n};\nfunction $57acba87d6e25586$var$useDebounceCallback(callback, delay) {\n  const handleCallback = $fnFM9$useCallbackRef(callback);\n  const debounceTimerRef = $fnFM9$useRef(0);\n  $fnFM9$useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);\n  return $fnFM9$useCallback(() => {\n    window.clearTimeout(debounceTimerRef.current);\n    debounceTimerRef.current = window.setTimeout(handleCallback, delay);\n  }, [handleCallback, delay]);\n}\nfunction $57acba87d6e25586$var$useResizeObserver(element, onResize) {\n  const handleResize = $fnFM9$useCallbackRef(onResize);\n  $fnFM9$useLayoutEffect(() => {\n    let rAF = 0;\n    if (element) {\n      /**\n      * Resize Observer will throw an often benign error that says `ResizeObserver loop\n      * completed with undelivered notifications`. This means that ResizeObserver was not\n      * able to deliver all observations within a single animation frame, so we use\n      * `requestAnimationFrame` to ensure we don't deliver unnecessary observations.\n      * Further reading: https://github.com/WICG/resize-observer/issues/38\n      */\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n      resizeObserver.observe(element);\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n  }, [element, handleResize]);\n}\n/* -----------------------------------------------------------------------------------------------*/\nconst $57acba87d6e25586$export$be92b6f5f03c0fe9 = $57acba87d6e25586$export$ccf8d8d7bbf3c2cc;\nconst $57acba87d6e25586$export$d5c6c08dc2d3ca7 = $57acba87d6e25586$export$a21cbf9f11fca853;\nconst $57acba87d6e25586$export$9a4e88b92edfce6b = $57acba87d6e25586$export$2fabd85d0eba3c57;\nconst $57acba87d6e25586$export$6521433ed15a34db = $57acba87d6e25586$export$9fba1154677d7cd2;\nconst $57acba87d6e25586$export$ac61190d9fc311a9 = $57acba87d6e25586$export$56969d565df7cc4b;\nexport { $57acba87d6e25586$export$488468afe3a6f2b1 as createScrollAreaScope, $57acba87d6e25586$export$ccf8d8d7bbf3c2cc as ScrollArea, $57acba87d6e25586$export$a21cbf9f11fca853 as ScrollAreaViewport, $57acba87d6e25586$export$2fabd85d0eba3c57 as ScrollAreaScrollbar, $57acba87d6e25586$export$9fba1154677d7cd2 as ScrollAreaThumb, $57acba87d6e25586$export$56969d565df7cc4b as ScrollAreaCorner, $57acba87d6e25586$export$be92b6f5f03c0fe9 as Root, $57acba87d6e25586$export$d5c6c08dc2d3ca7 as Viewport, $57acba87d6e25586$export$9a4e88b92edfce6b as Scrollbar, $57acba87d6e25586$export$6521433ed15a34db as Thumb, $57acba87d6e25586$export$ac61190d9fc311a9 as Corner };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}