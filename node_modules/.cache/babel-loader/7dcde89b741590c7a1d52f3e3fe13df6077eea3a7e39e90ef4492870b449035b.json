{"ast":null,"code":"import deepEqual from 'fast-deep-equal';\nconst globalCache = [];\nfunction handleAsset(fn, cache, args, lifespan = 0, preload = false) {\n  for (const entry of cache) {\n    // Find a match\n    if (deepEqual(args, entry.args)) {\n      // If we're pre-loading and the element is present, just return\n      if (preload) return; // If an error occurred, throw\n\n      if (entry.error) throw entry.error; // If a response was successful, return\n\n      if (entry.response) return entry.response; // If the promise is still unresolved, throw\n\n      throw entry.promise;\n    }\n  } // The request is new or has changed.\n\n  const entry = {\n    args,\n    promise:\n    // Make the promise request.\n    fn(...args) // Response can't be undefined or else the loop above wouldn't be able to return it\n    // This is for promises that do not return results (delays for instance)\n    .then(response => entry.response = response != null ? response : true).catch(e => entry.error = e != null ? e : 'unknown error').then(() => {\n      if (lifespan > 0) {\n        setTimeout(() => {\n          const index = cache.indexOf(entry);\n          if (index !== -1) cache.splice(index, 1);\n        }, lifespan);\n      }\n    })\n  };\n  cache.push(entry);\n  if (!preload) throw entry.promise;\n}\nfunction clear(cache, ...args) {\n  if (args === undefined || args.length === 0) cache.splice(0, cache.length);else {\n    const entry = cache.find(entry => deepEqual(args, entry.args));\n    if (entry) {\n      const index = cache.indexOf(entry);\n      if (index !== -1) cache.splice(index, 1);\n    }\n  }\n}\nfunction createAsset(fn, lifespan = 0) {\n  const cache = [];\n  return {\n    /**\n     * @throws Suspense Promise if asset is not yet ready\n     * @throws Error if the promise rejected for some reason\n     */\n    read: (...args) => handleAsset(fn, cache, args, lifespan),\n    preload: (...args) => void handleAsset(fn, cache, args, lifespan, true),\n    clear: (...args) => clear(cache, ...args),\n    peek: (...args) => {\n      var _cache$find;\n      return (_cache$find = cache.find(entry => deepEqual(args, entry.args))) == null ? void 0 : _cache$find.response;\n    }\n  };\n}\nfunction useAsset(fn, ...args) {\n  return handleAsset(fn, globalCache, args, useAsset.lifespan);\n}\nuseAsset.lifespan = 0;\nuseAsset.clear = (...args) => clear(globalCache, ...args);\nuseAsset.preload = (fn, ...args) => void handleAsset(fn, globalCache, args, useAsset.lifespan, true);\nuseAsset.peek = (...args) => {\n  var _globalCache$find;\n  return (_globalCache$find = globalCache.find(entry => deepEqual(args, entry.args))) == null ? void 0 : _globalCache$find.response;\n};\nexport { createAsset, useAsset };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}