{"ast":null,"code":"import $6vYhU$react from \"react\";\nimport { createContextScope as $6vYhU$createContextScope } from \"@radix-ui/react-context\";\nimport { useComposedRefs as $6vYhU$useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Slot as $6vYhU$Slot } from \"@radix-ui/react-slot\";\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>â€¦</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\nfunction $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {\n  /* -----------------------------------------------------------------------------------------------\n  * CollectionProvider\n  * ---------------------------------------------------------------------------------------------*/\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = $6vYhU$createContextScope(PROVIDER_NAME);\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {\n    collectionRef: {\n      current: null\n    },\n    itemMap: new Map()\n  });\n  const CollectionProvider = props => {\n    const {\n      scope: scope,\n      children: children\n    } = props;\n    const ref = $6vYhU$react.useRef(null);\n    const itemMap = $6vYhU$react.useRef(new Map()).current;\n    return /*#__PURE__*/$6vYhU$react.createElement(CollectionProviderImpl, {\n      scope: scope,\n      itemMap: itemMap,\n      collectionRef: ref\n    }, children);\n  };\n  /*#__PURE__*/\n  Object.assign(CollectionProvider, {\n    displayName: PROVIDER_NAME\n  });\n  /* -----------------------------------------------------------------------------------------------\n  * CollectionSlot\n  * ---------------------------------------------------------------------------------------------*/\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n  const CollectionSlot = /*#__PURE__*/$6vYhU$react.forwardRef((props, forwardedRef) => {\n    const {\n      scope: scope,\n      children: children\n    } = props;\n    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n    const composedRefs = $6vYhU$useComposedRefs(forwardedRef, context.collectionRef);\n    return /*#__PURE__*/$6vYhU$react.createElement($6vYhU$Slot, {\n      ref: composedRefs\n    }, children);\n  });\n  /*#__PURE__*/\n  Object.assign(CollectionSlot, {\n    displayName: COLLECTION_SLOT_NAME\n  });\n  /* -----------------------------------------------------------------------------------------------\n  * CollectionItem\n  * ---------------------------------------------------------------------------------------------*/\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n  const CollectionItemSlot = /*#__PURE__*/$6vYhU$react.forwardRef((props, forwardedRef) => {\n    const {\n      scope: scope,\n      children: children,\n      ...itemData\n    } = props;\n    const ref = $6vYhU$react.useRef(null);\n    const composedRefs = $6vYhU$useComposedRefs(forwardedRef, ref);\n    const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n    $6vYhU$react.useEffect(() => {\n      context.itemMap.set(ref, {\n        ref: ref,\n        ...itemData\n      });\n      return () => void context.itemMap.delete(ref);\n    });\n    return /*#__PURE__*/$6vYhU$react.createElement($6vYhU$Slot, {\n      [ITEM_DATA_ATTR]: '',\n      ref: composedRefs\n    }, children);\n  });\n  /*#__PURE__*/\n  Object.assign(CollectionItemSlot, {\n    displayName: ITEM_SLOT_NAME\n  });\n  /* -----------------------------------------------------------------------------------------------\n  * useCollection\n  * ---------------------------------------------------------------------------------------------*/\n  function useCollection(scope) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n    const getItems = $6vYhU$react.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort((a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current));\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n    return getItems;\n  }\n  return [{\n    Provider: CollectionProvider,\n    Slot: CollectionSlot,\n    ItemSlot: CollectionItemSlot\n  }, useCollection, createCollectionScope];\n}\nexport { $e02a7d9cb1dc128c$export$c74125a8e3af6bb2 as createCollection };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}