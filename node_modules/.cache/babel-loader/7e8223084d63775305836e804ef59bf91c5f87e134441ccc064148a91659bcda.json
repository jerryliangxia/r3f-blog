{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementData} ElementData\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n *\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Token.Location} P5Location\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n *\n * @typedef {import('vfile').VFile} VFile\n */\n\n/**\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {VFile | null | undefined} [file]\n *   File used to add positional info to nodes (optional).\n *\n *   If given, the file should represent the original HTML source.\n * @property {boolean | null | undefined} [verbose=false]\n *   Whether to add extra positional info about starting tags, closing tags,\n *   and attributes to elements (default: `false`).\n *\n *   > ðŸ‘‰ **Note**: only used when `file` is given.\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean} location\n *   Whether location info was found.\n * @property {Schema} schema\n *   Current schema.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n */\n\nimport { ok as assert } from 'devlop';\nimport { h, s } from 'hastscript';\nimport { find, html, svg } from 'property-information';\nimport { location } from 'vfile-location';\nimport { webNamespaces } from 'web-namespaces';\nconst own = {}.hasOwnProperty;\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nconst proto = Object.prototype;\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {P5Node} tree\n *   `parse5` tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  const settings = options || {};\n  return one({\n    file: settings.file || undefined,\n    location: false,\n    schema: settings.space === 'svg' ? svg : html,\n    verbose: settings.verbose || false\n  }, tree);\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} node\n *   p5 node.\n * @returns {Nodes}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Nodes} */\n  let result;\n  switch (node.nodeName) {\n    case '#comment':\n      {\n        const reference = /** @type {P5Comment} */node;\n        result = {\n          type: 'comment',\n          value: reference.data\n        };\n        patch(state, reference, result);\n        return result;\n      }\n    case '#document':\n    case '#document-fragment':\n      {\n        const reference = /** @type {P5Document | P5DocumentFragment} */node;\n        const quirksMode = 'mode' in reference ? reference.mode === 'quirks' || reference.mode === 'limited-quirks' : false;\n        result = {\n          type: 'root',\n          children: all(state, node.childNodes),\n          data: {\n            quirksMode\n          }\n        };\n        if (state.file && state.location) {\n          const doc = String(state.file);\n          const loc = location(doc);\n          const start = loc.toPoint(0);\n          const end = loc.toPoint(doc.length);\n          // Always defined as we give valid input.\n          assert(start, 'expected `start`');\n          assert(end, 'expected `end`');\n          result.position = {\n            start,\n            end\n          };\n        }\n        return result;\n      }\n    case '#documentType':\n      {\n        const reference = /** @type {P5DocumentType} */node;\n        result = {\n          type: 'doctype'\n        };\n        patch(state, reference, result);\n        return result;\n      }\n    case '#text':\n      {\n        const reference = /** @type {P5Text} */node;\n        result = {\n          type: 'text',\n          value: reference.value\n        };\n        patch(state, reference, result);\n        return result;\n      }\n\n    // Element.\n    default:\n      {\n        const reference = /** @type {P5Element} */node;\n        result = element(state, reference);\n        return result;\n      }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<P5Node>} nodes\n *   Nodes.\n * @returns {Array<RootContent>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  let index = -1;\n  /** @type {Array<RootContent>} */\n  const results = [];\n  while (++index < nodes.length) {\n    // Assume no roots in `nodes`.\n    const result = /** @type {RootContent} */one(state, nodes[index]);\n    results.push(result);\n  }\n  return results;\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Element} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  const schema = state.schema;\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html;\n\n  // Props.\n  let index = -1;\n  /** @type {Record<string, string>} */\n  const props = {};\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index];\n    const name = (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name;\n    if (!own.call(proto, name)) {\n      props[name] = attribute.value;\n    }\n  }\n\n  // Build.\n  const fn = state.schema.space === 'svg' ? s : h;\n  const result = fn(node.tagName, props, all(state, node.childNodes));\n  patch(state, node, result);\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    const reference = /** @type {P5Template} */node;\n    const pos = reference.sourceCodeLocation;\n    const startTag = pos && pos.startTag && position(pos.startTag);\n    const endTag = pos && pos.endTag && position(pos.endTag);\n\n    // Root in, root out.\n    const content = /** @type {Root} */one(state, reference.content);\n    if (startTag && endTag && state.file) {\n      content.position = {\n        start: startTag.end,\n        end: endTag.start\n      };\n    }\n    result.content = content;\n  }\n  state.schema = schema;\n  return result;\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} from\n *   p5 node.\n * @param {Nodes} to\n *   hast node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation);\n    if (position) {\n      state.location = true;\n      to.position = position;\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node.\n * @param {P5ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  const result = position(location);\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1];\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (result && !location.endTag && tail && tail.position && tail.position.end) {\n      result.end = Object.assign({}, tail.position.end);\n    }\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const props = {};\n      /** @type {string} */\n      let key;\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            props[find(state.schema, key).property] = position(location.attrs[key]);\n          }\n        }\n      }\n      assert(location.startTag, 'a start tag should exist');\n      const opening = position(location.startTag);\n      const closing = location.endTag ? position(location.endTag) : undefined;\n      /** @type {ElementData['position']} */\n      const data = {\n        opening\n      };\n      if (closing) data.closing = closing;\n      data.properties = props;\n      node.data = {\n        position: data\n      };\n    }\n  }\n  return result;\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {P5Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  });\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  });\n\n  // @ts-expect-error: we do use `undefined` for points if one or the other\n  // exists.\n  return start || end ? {\n    start,\n    end\n  } : undefined;\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}