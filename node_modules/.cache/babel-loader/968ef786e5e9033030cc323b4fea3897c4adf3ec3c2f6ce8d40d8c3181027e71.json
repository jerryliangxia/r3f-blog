{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('vfile').Value} Value\n * @typedef {import('unist').Point} UnistPoint\n */\n\n/**\n *\n * @typedef PointLike\n *   unist point, allowed as input.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @callback ToPoint\n *   Get the line/column based `Point` for `offset` in the bound indices.\n *\n *   Returns `undefined` when given out of bounds input.\n *\n *   Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n *   [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n * @param {number | null | undefined} [offset]\n *   Something that should be an `offset.\n * @returns {UnistPoint | undefined}\n *   Point, if `offset` is valid and in-bounds input.\n *\n * @callback ToOffset\n *   Get the `offset` from a line/column based `Point` in the bound indices.\n * @param {PointLike | null | undefined} [point]\n *   Something that should be a `point.\n * @returns {number | undefined}\n *   Offset (`number`) or `undefined` for invalid or out of bounds input.\n *\n * @typedef Location\n *   Accessors for index.\n * @property {ToPoint} toPoint\n *   Get the line/column based `Point` for `offset` in the bound indices.\n * @property {ToOffset} toOffset\n *   Get the `offset` from a line/column based `Point` in the bound indices.\n */\n\nconst search = /\\r?\\n|\\r/g;\n\n/**\n * Create an index of the given document to translate between line/column and\n * offset based positional info.\n *\n * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nexport function location(file) {\n  const value = String(file);\n  /**\n   * List, where each index is a line number (0-based), and each value is the\n   * byte index *after* where the line ends.\n   *\n   * @type {Array<number>}\n   */\n  const indices = [];\n  search.lastIndex = 0;\n  while (search.test(value)) {\n    indices.push(search.lastIndex);\n  }\n  indices.push(value.length + 1);\n  return {\n    toPoint,\n    toOffset\n  };\n\n  /** @type {ToPoint} */\n  function toPoint(offset) {\n    let index = -1;\n    if (typeof offset === 'number' && offset > -1 && offset < indices[indices.length - 1]) {\n      while (++index < indices.length) {\n        if (indices[index] > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset\n          };\n        }\n      }\n    }\n  }\n\n  /** @type {ToOffset} */\n  function toOffset(point) {\n    const line = point && point.line;\n    const column = point && point.column;\n    if (typeof line === 'number' && typeof column === 'number' && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {\n      const offset = (indices[line - 2] || 0) + column - 1 || 0;\n      if (offset > -1 && offset < indices[indices.length - 1]) {\n        return offset;\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}