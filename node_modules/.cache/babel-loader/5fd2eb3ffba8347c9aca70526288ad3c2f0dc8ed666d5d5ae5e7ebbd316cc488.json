{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport * as TooltipPrimitive from '@radix-ui/react-tooltip';\nimport { DirectionProvider } from '@radix-ui/react-direction';\nimport { Slot } from '@radix-ui/react-slot';\nimport { themePropDefs, getMatchingGrayColor } from './theme-options';\nconst noop = () => {};\nconst ThemeContext = React.createContext(undefined);\nfunction useThemeContext() {\n  const context = React.useContext(ThemeContext);\n  if (context === undefined) {\n    throw new Error('`useThemeContext` must be used within a `Theme`');\n  }\n  return context;\n}\nconst Theme = React.forwardRef((props, forwardedRef) => {\n  const context = React.useContext(ThemeContext);\n  const isRoot = context === undefined;\n  if (isRoot) {\n    return React.createElement(TooltipPrimitive.Provider, null, React.createElement(DirectionProvider, {\n      dir: \"ltr\"\n    }, React.createElement(ThemeRoot, {\n      ...props,\n      ref: forwardedRef\n    })));\n  }\n  return React.createElement(ThemeImpl, {\n    ...props,\n    ref: forwardedRef\n  });\n});\nTheme.displayName = 'Theme';\nconst ThemeRoot = React.forwardRef((props, forwardedRef) => {\n  const {\n    appearance: appearanceProp = themePropDefs.appearance.default,\n    accentColor: accentColorProp = themePropDefs.accentColor.default,\n    grayColor: grayColorProp = themePropDefs.grayColor.default,\n    panelBackground: panelBackgroundProp = themePropDefs.panelBackground.default,\n    radius: radiusProp = themePropDefs.radius.default,\n    scaling: scalingProp = themePropDefs.scaling.default,\n    hasBackground = themePropDefs.hasBackground.default,\n    ...rootProps\n  } = props;\n  const [appearance, setAppearance] = React.useState(appearanceProp);\n  React.useEffect(() => setAppearance(appearanceProp), [appearanceProp]);\n  const [accentColor, setAccentColor] = React.useState(accentColorProp);\n  React.useEffect(() => setAccentColor(accentColorProp), [accentColorProp]);\n  const [grayColor, setGrayColor] = React.useState(grayColorProp);\n  React.useEffect(() => setGrayColor(grayColorProp), [grayColorProp]);\n  const [panelBackground, setPanelBackground] = React.useState(panelBackgroundProp);\n  React.useEffect(() => setPanelBackground(panelBackgroundProp), [panelBackgroundProp]);\n  const [radius, setRadius] = React.useState(radiusProp);\n  React.useEffect(() => setRadius(radiusProp), [radiusProp]);\n  const [scaling, setScaling] = React.useState(scalingProp);\n  React.useEffect(() => setScaling(scalingProp), [scalingProp]);\n  // Initial appearance on page load when `appearance` is explicitly set to `light` or `dark`\n  const ExplicitRootAppearanceScript = React.memo(({\n    appearance\n  }) => React.createElement(\"script\", {\n    dangerouslySetInnerHTML: {\n      __html: `!(function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');d.style.colorScheme='${appearance}';c.add('${appearance}');}catch(e){}})();`\n    }\n  }), () => true // Never re-render\n  );\n\n  ExplicitRootAppearanceScript.displayName = 'ExplicitRootAppearanceScript';\n  // Client-side only changes when `appearance` prop is changed while developing\n  React.useEffect(() => updateThemeAppearanceClass(appearanceProp), [appearanceProp]);\n  const resolvedGrayColor = grayColor === 'auto' ? getMatchingGrayColor(accentColor) : grayColor;\n  return React.createElement(React.Fragment, null, appearance !== 'inherit' && React.createElement(ExplicitRootAppearanceScript, {\n    appearance: appearance\n  }), hasBackground && React.createElement(\"style\", {\n    dangerouslySetInnerHTML: {\n      __html: `\n:root, .light, .light-theme { --color-page-background: white; }\n.dark, .dark-theme { --color-page-background: var(--${resolvedGrayColor}-1); }\nbody { background-color: var(--color-page-background); }\n`\n    }\n  }), React.createElement(ThemeImpl, {\n    ...rootProps,\n    ref: forwardedRef,\n    isRoot: true,\n    hasBackground: hasBackground,\n    //\n    appearance: appearance,\n    accentColor: accentColor,\n    grayColor: grayColor,\n    panelBackground: panelBackground,\n    radius: radius,\n    scaling: scaling,\n    //\n    onAppearanceChange: setAppearance,\n    onAccentColorChange: setAccentColor,\n    onGrayColorChange: setGrayColor,\n    onPanelBackgroundChange: setPanelBackground,\n    onRadiusChange: setRadius,\n    onScalingChange: setScaling\n  }));\n});\nThemeRoot.displayName = 'ThemeRoot';\nconst ThemeImpl = React.forwardRef((props, forwardedRef) => {\n  var _a, _b, _c, _d, _e, _f;\n  const context = React.useContext(ThemeContext);\n  const {\n    asChild,\n    isRoot,\n    hasBackground,\n    //\n    appearance = (_a = context === null || context === void 0 ? void 0 : context.appearance) !== null && _a !== void 0 ? _a : themePropDefs.appearance.default,\n    accentColor = (_b = context === null || context === void 0 ? void 0 : context.accentColor) !== null && _b !== void 0 ? _b : themePropDefs.accentColor.default,\n    grayColor = (_c = context === null || context === void 0 ? void 0 : context.resolvedGrayColor) !== null && _c !== void 0 ? _c : themePropDefs.grayColor.default,\n    panelBackground = (_d = context === null || context === void 0 ? void 0 : context.panelBackground) !== null && _d !== void 0 ? _d : themePropDefs.panelBackground.default,\n    radius = (_e = context === null || context === void 0 ? void 0 : context.radius) !== null && _e !== void 0 ? _e : themePropDefs.radius.default,\n    scaling = (_f = context === null || context === void 0 ? void 0 : context.scaling) !== null && _f !== void 0 ? _f : themePropDefs.scaling.default,\n    //\n    onAppearanceChange = noop,\n    onAccentColorChange = noop,\n    onGrayColorChange = noop,\n    onPanelBackgroundChange = noop,\n    onRadiusChange = noop,\n    onScalingChange = noop,\n    //\n    ...themeProps\n  } = props;\n  const Comp = asChild ? Slot : 'div';\n  const resolvedGrayColor = grayColor === 'auto' ? getMatchingGrayColor(accentColor) : grayColor;\n  const isExplicitAppearance = props.appearance !== undefined && props.appearance !== 'inherit';\n  const isExplicitGrayColor = props.grayColor !== undefined;\n  const shouldHaveBackground = !isRoot && (hasBackground === true || hasBackground !== false && (isExplicitAppearance || isExplicitGrayColor));\n  return React.createElement(ThemeContext.Provider, {\n    value: React.useMemo(() => ({\n      appearance,\n      accentColor,\n      grayColor,\n      resolvedGrayColor,\n      panelBackground,\n      radius,\n      scaling,\n      //\n      onAppearanceChange,\n      onAccentColorChange,\n      onGrayColorChange,\n      onPanelBackgroundChange,\n      onRadiusChange,\n      onScalingChange\n    }), [appearance, accentColor, grayColor, resolvedGrayColor, panelBackground, radius, scaling,\n    //\n    onAppearanceChange, onAccentColorChange, onGrayColorChange, onPanelBackgroundChange, onRadiusChange, onScalingChange])\n  }, React.createElement(Comp, {\n    \"data-is-root-theme\": isRoot ? 'true' : 'false',\n    \"data-accent-color\": accentColor,\n    \"data-gray-color\": resolvedGrayColor,\n    \"data-has-background\": shouldHaveBackground ? 'true' : 'false',\n    \"data-panel-background\": panelBackground,\n    \"data-radius\": radius,\n    \"data-scaling\": scaling,\n    ref: forwardedRef,\n    ...themeProps,\n    className: classNames('radix-themes', {\n      // Only apply theme class to nested `Theme` sections.\n      //\n      // If it's the root `Theme`, we either rely on\n      // - something else setting the theme class when root `appearance` is `inherit`\n      // - our script setting it when root `appearance` is explicit\n      light: !isRoot && appearance === 'light',\n      dark: !isRoot && appearance === 'dark'\n    }, themeProps.className)\n  }));\n});\nThemeImpl.displayName = 'ThemeImpl';\nfunction updateThemeAppearanceClass(appearance) {\n  if (appearance === 'inherit') return;\n  const root = document.documentElement;\n  if (root.classList.contains('light-theme') || root.classList.contains('dark-theme')) {\n    root.classList.remove('light-theme', 'dark-theme');\n    root.style.colorScheme = appearance;\n    root.classList.add(`${appearance}-theme`);\n  }\n  if (root.classList.contains('light') || root.classList.contains('dark')) {\n    root.classList.remove('light', 'dark');\n    root.style.colorScheme = appearance;\n    root.classList.add(appearance);\n  }\n}\nexport { Theme, useThemeContext, updateThemeAppearanceClass };\n//# sourceMappingURL=theme.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}